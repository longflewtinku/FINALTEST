apply plugin: 'jacoco'

jacoco {
    toolVersion '0.8.8'
}

tasks.withType(Test) {
    jacoco.includeNoLocationClasses = true
    jacoco.excludes = ['jdk.internal.*']
}

task allDebugCoverage(type: JacocoReport) {
    // Debug and all the linkly connect flavours. There must be a better way of doing this but at this point I am unsure.
    def variants = ["debug", "pa_linklyDebug"]//, "pa_verifone_gpaDebug", "vfiDebug"]

    group = "Reporting"
    description = "Generate overall Jacoco coverage report for the debug build."

    reports {
        xml.required = true
        html.required = true
    }

    def excludes = [
            // data binding
            'android/databinding/**/*.class',
            '**/android/databinding/*Binding.class',
            '**/android/databinding/*',
            '**/androidx/databinding/*',
            '**/BR.*',
            // android
            '**/R.class',
            '**/R$*.class',
            '**/BuildConfig.*',
            '**/Manifest*.*',
            '**/*Test*.*',
            'android/**/*.*',
            // kotlin
            '**/*MapperImpl*.*',
            '**/*$ViewInjector*.*',
            '**/*$ViewBinder*.*',
            '**/BuildConfig.*',
            '**/*Component*.*',
            '**/*BR*.*',
            '**/Manifest*.*',
            '**/*$Lambda$*.*',
            '**/*Companion*.*',
            '**/*Module*.*',
            '**/*Dagger*.*',
            '**/dagger*/*',
            '**/*Hilt*.*',
            '**/hilt*/*',
            '**/*MembersInjector*.*',
            '**/*_MembersInjector.class',
            '**/*_Factory*.*',
            '**/*_Provide*Factory*.*',
            '**/*Extensions*.*',
            // sealed and data classes
            '**/*$Result.*',
            '**/*$Result$*.*',
            // adapters generated by moshi
            '**/*JsonAdapter.*',
    ]

    // Due to issues with exactly the same name this causes issues with code coverage.
    def ignoreList = ["resdemo", "reslivegroup", "restill", "resvirgin", "reswoolworths", "resnetcabs"]
    def filteredProjects = subprojects.findAll {proj ->
        !ignoreList.contains(proj.name)
    }

    def jClasses = filteredProjects.collect { proj ->
        variants.collect { variant ->
            "${proj.buildDir}/intermediates/javac/$variant/classes"
        }
    }.flatten()

    def kClasses = filteredProjects.collect { proj ->
        variants.collect { variant ->
            "${proj.buildDir}/tmp/kotlin-classes/$variant"
        }
    }.flatten()

    def javaClasses = jClasses.collect { path ->
        fileTree(dir: path, excludes: excludes)
    }

    def kotlinClasses = kClasses.collect { path ->
        fileTree(dir: path, excludes: excludes)
    }

    classDirectories.from = files([javaClasses, kotlinClasses])

    def sources = filteredProjects.collect { proj ->
        variants.collect { variant ->
            ["${proj.projectDir}/src/main/java", "${proj.projectDir}/src/main/kotlin",
             "${proj.projectDir}/src/$variant/java", "${proj.projectDir}/src/$variant/kotlin"]
        }.flatten()
    }.flatten()

    sourceDirectories.from = files(sources)

    def executions = filteredProjects.collect { proj ->
        def project = proj.name
        variants.collect { variant ->
            def path = "${proj.buildDir}/outputs/unit_test_code_coverage/${variant}UnitTest/test${variant.capitalize()}UnitTest.exec"
            if ((new File(path)).exists()) path else null
        }
    }.flatten()
    executions.removeAll([null])

    executionData.from = files(executions)
}
